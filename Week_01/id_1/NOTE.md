### 一. 第一周学习总结

#### 1. 关于链表题目的做题总结

做了作业中两道关于链表的题目，结合以前做的链表题目，发现自己用的方法基本有三种：

- 遍历：链表和数组一样，基本的遍历是逃不了的，重点是怎么提高遍历效率的问题。
- 反转：反转也是常用的方式，关于反转最主要的是记录三个节点：当前节点，当前节点的 prev 节点和 next 节点。整个反转过程就是这三个节点的不断变化。然后在反转的过程中可能需要做一些特殊的处理，比如本周的 LeetCode 24、25两道题目，都是要在反转的时候要讲前一组的尾节点的 next 指向本次反转后的头节点。
- 快慢指针：包括查看链表是否有环，获取链表的中间节点等题目都可以用快慢指针的方式进行，当快指针到达末尾时，满指针刚好到达链表的中间，有环的话两者最终有机会相遇。


#### 2. pow(x, n) 解题思路与递归简记

最先想到的就是循环相乘了，先暴力搞出来再说，代码如下

```Java

public class Solution {
    double myPow(double x, int n) {
        int result = 1;
        for (int i = 1; i <= n; i ++) {
            result *= x;
        }
        return result;
    }
}
```

这种解法时间复杂度为 O(N)，实际提交可能会超时，因此需要改进。这里用到数学知识：

> a^m * a^n = a^(m+n)

因此以 2 的 10 次方为例：

```
2^10 = 2^5 * 2^5
2^5 = 2^2 * 2^2 * 2
2^2 = 2^1 * 2^1
2^1 = 2^0 * 2
```

因此每一个指数幂的计算都可以进行折半计算，这样就可以通过递归的形式进行计算。

递归公式为：

```
n 为偶数： x^n = x^(n/2) * x^(n/2)
n 为奇数： x^n = x^(n/2) * x^(n/2) * x
```

终止条件为：

```
n = 0, x^0 = 1
```

实现代码如下：

```Java
public class Solution {
    double myPow(double x, int n) { 
        
        double result = this.pow(x, Math.abs(n));
        
        if (n < 0) {
            return -n;
        }
        return n;
    }

    private double pow(double x, int n) {
        if (n == 0) {
            return 1;
        }
        double half = pow(x, n / 2);
        if (n % 2 == 0) {
            return half * half;
        } else {
            return half * half * x;
        }
    }
}
```

最终返回结果要考虑 n 为负数的情况，因此先取绝对值进行计算，如果为负数则返回计算结果的倒数。整个算法的复杂度由 O(N) 变为了 O(logN)。

关于递归最重要的还是要找到递归公式，如王争老师在专栏中提到的三步：

- 分解出子问题，子问题的解题思路通用：这里的 a^m * a^n = a^(m+n) 就是典型的案例。
- 递归过程的计算：每次计算的结果是子问题的结果汇总，这里就是指数为奇数和偶数时的不同的计算公式。
- 终止条件：这里的终止条件就是幂为 0 的时候。

