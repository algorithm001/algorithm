# 学习笔记
> 递归树、堆和排序、图、深度和广度优先搜索、字符串匹配

递归树
> 主要就是用来分析递归代码的时间复杂度？

堆
> 很重要的一种数据结构，日常工作中使用率也比较高。比如：常用的优先级队列、堆排序。
一些理解点：
 * 本身是一棵完全二叉树（除最后一层，其他层节点都是满的，最后一层如果只有一个节点，必须考左）
 * 一般用数组来存储，而且可以利用数组下标快速的方法定位父节点((i-1)/2)、左右子节点（l=2i*-1,r=2i*2）
 * 大顶堆，当前节点值，大于等于左右节点值。小顶堆，当前节点值，小于等于左右节点值。
> 一个大顶堆，存储它的数组是有序的吗？
```
                 67
               /   \
              56    23
             / \    / \
            45 11  7  13
           / \ /
          12 5 6 
      +----+----+----+----+----+----+----+----+----+----+
      | 67 | 56 | 23 | 45 | 11 | 7  | 13 | 12 |  5 | 6  |
      +----+----+----+----+----+----+----+----+----+----+
   这个一个大顶堆，下面是数组的存储情况。 显然，存储它的数组不是有序的。
``` 
> 基于上一点的特性，我们取堆中的top k按大小顺序的元素，要么不断的删除堆顶元素，然后再次堆化；要么将堆排序输出，其实也是，不断的删除堆顶元素，然后在0...n-1的范围内堆化。动态的数据，要是把堆顶元素删除了，元素就不存在了，如果是top k问题，其实是使用小顶堆。
建堆& 动态操作：
   * 原始数组的堆化，一种从前往后(插入，也是从下往上堆化？)；一种从后往前(只需要从n/2-1的节点开始，往前遍历建堆)
   * 堆排序：建堆后，迭代删除堆顶，并堆化剩余的N-1的堆
   * 删除堆顶&插入新元素：删除一般采用：用n-1位置的元素放入下标为0的堆顶位置，然后向下堆化。插入到n-1的位置，然后向上堆化。

图：
> 无向图、有向图、带权图、无向/有向带权图

注意跟进实际场景，选择图的存储方式，是使用邻接矩阵还是邻接表。比如：顶点比较多，但是顶点间关系（边）不多的，邻接表更适合。可以把王争老师说的微信、微博这些社交关系的仔细推导、实现一下。
BFS & DFS
> 图的搜索遍历。上周也简单总结了一下。整体的感觉：离融会贯通还有很长的距离，现在很多点，还是各自游离状态。
```
  广度优先，没实现前，记得当时的一个图，一层层去遍历，也记得有个队列。自己实现是走迷宫，实际实现就是从当前点，依次查看当前点的右、下、左、上是否可走，可走的话，就把右、下、左、上的点，加入队尾，然后从队头中取一个元素作为当前点，再重复这个过程。利用队列的先进先出(FIFO)，就实现了"层层推进"的效果。
  深度优先，则是采用栈的后进先出(LIFO)特性。实现了"一条路走到黑"的效果，只有真正没路可走了，而且还没走出迷宫，这时才能回到"岔路口"从另一条路再这样"一条路走到黑",每个岔路口，都是这样干的。这就是回溯（Backtrack)?
```

字符串匹配
> BF当然是最好理解，但是由于效率低。出现了RK算法。本质上是：RK利用哈希表，来提高字符串比较的效率。
> BM/KMP,思路上主要也是，减少字符串比较的次数。有机会多滑动几位，就可以减少模式串和主串的比较次数。KMP的next数组还没看明白:(
