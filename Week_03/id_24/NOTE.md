# 学习笔记

[703. 数据流中的第k个大元素](https://leetcode-cn.com/problems/kth-largest-element-in-a-stream)

第一遍做的时候忘记了可以使用堆来处理这个问题，使用的是最简单暴力的数组存储方式，建立一个存储k个元素的数组，每次读取元素后，判断是否
需要把新元素插入到数组中去，如果需要插入则删除现在数组中最小的元素，插入该元素并重新进行一次排序。这个方法在运行到最后一个测试时报出
超出时间限制的问题。重新思考问题时，就想着如何能够优化后面数组的排序，才想到堆排序可以处理这个问题。

第二遍实践的过程
构建一个小顶堆大小为k，学习如何堆化，如何存储一个堆
利用数组存储堆，节点为i的位置，存储的左节点的位置为2*i，右节点的位置为2*i+1，堆化分为
从上往下和从下往上两种堆化方式.
难点：需要进一步练习堆化的过程。

[997. 找到小镇的法官](https://leetcode-cn.com/problems/find-the-town-judge/)

解题思路：看到这类问题首先想到了领接表和逆邻接表存储信任关系，根据条件查找是否满足给定的题目条件。
处理过程比较简单，实际代码完成过程中还是出现了两个问题，
1.忽略了边界条件，信任数组为空且N=1的情况；
2.忘记了反向查找，没有去逆邻接表中查找法官候选人是否信任其他人
